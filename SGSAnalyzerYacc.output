Conflict in state 49 between rule 35 and token ASSIGN resolved as shift.
Conflict in state 49 between rule 35 and token ADD resolved as shift.
Conflict in state 49 between rule 35 and token SUB resolved as shift.
Conflict in state 49 between rule 35 and token MUL resolved as shift.
Conflict in state 49 between rule 35 and token DIV resolved as shift.
Conflict in state 49 between rule 35 and token LEFT_PAREN resolved as shift.
Conflict in state 50 between rule 31 and token ASSIGN resolved as reduce.
Conflict in state 50 between rule 31 and token ADD resolved as reduce.
Conflict in state 50 between rule 31 and token SUB resolved as reduce.
Conflict in state 50 between rule 31 and token MUL resolved as shift.
Conflict in state 50 between rule 31 and token DIV resolved as shift.
Conflict in state 50 between rule 31 and token LEFT_PAREN resolved as shift.
Conflict in state 51 between rule 32 and token ASSIGN resolved as reduce.
Conflict in state 51 between rule 32 and token ADD resolved as reduce.
Conflict in state 51 between rule 32 and token SUB resolved as reduce.
Conflict in state 51 between rule 32 and token MUL resolved as shift.
Conflict in state 51 between rule 32 and token DIV resolved as shift.
Conflict in state 51 between rule 32 and token LEFT_PAREN resolved as shift.
Conflict in state 52 between rule 33 and token ASSIGN resolved as reduce.
Conflict in state 52 between rule 33 and token ADD resolved as reduce.
Conflict in state 52 between rule 33 and token SUB resolved as reduce.
Conflict in state 52 between rule 33 and token MUL resolved as reduce.
Conflict in state 52 between rule 33 and token DIV resolved as reduce.
Conflict in state 52 between rule 33 and token LEFT_PAREN resolved as shift.
Conflict in state 53 between rule 34 and token ASSIGN resolved as reduce.
Conflict in state 53 between rule 34 and token ADD resolved as reduce.
Conflict in state 53 between rule 34 and token SUB resolved as reduce.
Conflict in state 53 between rule 34 and token MUL resolved as reduce.
Conflict in state 53 between rule 34 and token DIV resolved as reduce.
Conflict in state 53 between rule 34 and token LEFT_PAREN resolved as shift.
Conflict in state 69 between rule 15 and token ELSE resolved as shift.

Grammar
rule 1    final -> statement
rule 2    final -> final statement
rule 3    statements_list -> statement
rule 4    statements_list -> statements_list statement
rule 5    parameters -> IDENTIFIER
rule 6    parameters -> parameters COMMA IDENTIFIER
rule 7    arguments -> expression
rule 8    arguments -> arguments COMMA expression
rule 9    statement -> SEMICOLON
rule 10   statement -> LEFT_BRACE RIGHT_BRACE
rule 11   statement -> expression SEMICOLON
rule 12   statement -> LEFT_BRACE statements_list RIGHT_BRACE
rule 13   statement -> VAR IDENTIFIER SEMICOLON
rule 14   statement -> VAR IDENTIFIER ASSIGN expression SEMICOLON
rule 15   statement -> IF LEFT_PAREN expression RIGHT_PAREN statement
rule 16   statement -> IF LEFT_PAREN expression RIGHT_PAREN statement ELSE statement
rule 17   statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN statement
rule 18   statement -> WHILE LEFT_PAREN expression RIGHT_PAREN statement
rule 19   statement -> DO statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
rule 20   expression -> DOUBLE_LITERAL
rule 21   expression -> INTEGER_LITERAL
rule 22   expression -> STRING_LITERAL
rule 23   expression -> IDENTIFIER
rule 24   expression -> FUNCTION IDENTIFIER LEFT_PAREN parameters RIGHT_PAREN statement
rule 25   expression -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN statement
rule 26   expression -> FUNCTION LEFT_PAREN parameters RIGHT_PAREN statement
rule 27   expression -> FUNCTION LEFT_PAREN RIGHT_PAREN statement
rule 28   expression -> LEFT_PAREN expression RIGHT_PAREN
rule 29   expression -> expression LEFT_PAREN RIGHT_PAREN
rule 30   expression -> expression LEFT_PAREN arguments RIGHT_PAREN
rule 31   expression -> expression ADD expression
rule 32   expression -> expression SUB expression
rule 33   expression -> expression MUL expression
rule 34   expression -> expression DIV expression
rule 35   expression -> expression ASSIGN expression

Terminals, with rules where they appear

$ (-1)
error (256)
IF (257) 15 16
FOR (258) 17
WHILE (259) 18 19
DO (260) 19
FUNCTION (261) 24 25 26 27
VAR (262) 13 14
DOUBLE_LITERAL (263) 20
INTEGER_LITERAL (264) 21
STRING_LITERAL (265) 22
IDENTIFIER (266) 5 6 13 14 23 24 25
RIGHT_PAREN (267) 15 16 17 18 19 24 25 26 27 28 29 30
LEFT_BRACE (268) 10 12
RIGHT_BRACE (269) 10 12
SEMICOLON (270) 9 11 13 14 17 19
COMMA (271) 6 8
ASSIGN (272) 14 35
ADD (273) 31
SUB (274) 32
MUL (275) 33
DIV (276) 34
IFX (277)
ELSE (278) 16
LEFT_PAREN (279) 15 16 17 18 19 24 25 26 27 28 29 30

Nonterminals, with rules where they appear

final (26)
    on left: 1 2, on right: 2
statements_list (27)
    on left: 3 4, on right: 4 12
parameters (28)
    on left: 5 6, on right: 6 24 26
arguments (29)
    on left: 7 8, on right: 8 30
statement (30)
    on left: 9 10 11 12 13 14 15 16 17 18 19, on right: 1 2 3 4 15
    16 17 18 19 24 25 26 27
expression (31)
    on left: 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35,
    on right: 7 8 11 14 15 16 17 18 19 28 29 30 31 32 33 34 35


state 0

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    final	go to state 14
    statement	go to state 15
    expression	go to state 16



state 1

    statement  ->  IF . LEFT_PAREN expression RIGHT_PAREN statement   (rule 15)
    statement  ->  IF . LEFT_PAREN expression RIGHT_PAREN statement ELSE statement   (rule 16)

    LEFT_PAREN	shift, and go to state 17



state 2

    statement  ->  FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN statement   (rule 17)

    LEFT_PAREN	shift, and go to state 18



state 3

    statement  ->  WHILE . LEFT_PAREN expression RIGHT_PAREN statement   (rule 18)

    LEFT_PAREN	shift, and go to state 19



state 4

    statement  ->  DO . statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON   (rule 19)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 20
    expression	go to state 16



state 5

    expression  ->  FUNCTION . IDENTIFIER LEFT_PAREN parameters RIGHT_PAREN statement   (rule 24)
    expression  ->  FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN statement   (rule 25)
    expression  ->  FUNCTION . LEFT_PAREN parameters RIGHT_PAREN statement   (rule 26)
    expression  ->  FUNCTION . LEFT_PAREN RIGHT_PAREN statement   (rule 27)

    IDENTIFIER	shift, and go to state 21
    LEFT_PAREN	shift, and go to state 22



state 6

    statement  ->  VAR . IDENTIFIER SEMICOLON   (rule 13)
    statement  ->  VAR . IDENTIFIER ASSIGN expression SEMICOLON   (rule 14)

    IDENTIFIER	shift, and go to state 23



state 7

    expression  ->  DOUBLE_LITERAL .   (rule 20)

    $default	reduce using rule 20 (expression)



state 8

    expression  ->  INTEGER_LITERAL .   (rule 21)

    $default	reduce using rule 21 (expression)



state 9

    expression  ->  STRING_LITERAL .   (rule 22)

    $default	reduce using rule 22 (expression)



state 10

    expression  ->  IDENTIFIER .   (rule 23)

    $default	reduce using rule 23 (expression)



state 11

    statement  ->  LEFT_BRACE . RIGHT_BRACE   (rule 10)
    statement  ->  LEFT_BRACE . statements_list RIGHT_BRACE   (rule 12)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    RIGHT_BRACE	shift, and go to state 24
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statements_list	go to state 25
    statement	go to state 26
    expression	go to state 16



state 12

    statement  ->  SEMICOLON .   (rule 9)

    $default	reduce using rule 9 (statement)



state 13

    expression  ->  LEFT_PAREN . expression RIGHT_PAREN   (rule 28)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 27



state 14

    final  ->  final . statement   (rule 2)

    $   	go to state 88
    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 28
    expression	go to state 16



state 15

    final  ->  statement .   (rule 1)

    $default	reduce using rule 1 (final)



state 16

    statement  ->  expression . SEMICOLON   (rule 11)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    SEMICOLON	shift, and go to state 29
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 17

    statement  ->  IF LEFT_PAREN . expression RIGHT_PAREN statement   (rule 15)
    statement  ->  IF LEFT_PAREN . expression RIGHT_PAREN statement ELSE statement   (rule 16)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 36



state 18

    statement  ->  FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN statement   (rule 17)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 37



state 19

    statement  ->  WHILE LEFT_PAREN . expression RIGHT_PAREN statement   (rule 18)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 38



state 20

    statement  ->  DO statement . WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON   (rule 19)

    WHILE	shift, and go to state 39



state 21

    expression  ->  FUNCTION IDENTIFIER . LEFT_PAREN parameters RIGHT_PAREN statement   (rule 24)
    expression  ->  FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN statement   (rule 25)

    LEFT_PAREN	shift, and go to state 40



state 22

    expression  ->  FUNCTION LEFT_PAREN . parameters RIGHT_PAREN statement   (rule 26)
    expression  ->  FUNCTION LEFT_PAREN . RIGHT_PAREN statement   (rule 27)

    IDENTIFIER	shift, and go to state 41
    RIGHT_PAREN	shift, and go to state 42

    parameters	go to state 43



state 23

    statement  ->  VAR IDENTIFIER . SEMICOLON   (rule 13)
    statement  ->  VAR IDENTIFIER . ASSIGN expression SEMICOLON   (rule 14)

    SEMICOLON	shift, and go to state 44
    ASSIGN	shift, and go to state 45



state 24

    statement  ->  LEFT_BRACE RIGHT_BRACE .   (rule 10)

    $default	reduce using rule 10 (statement)



state 25

    statements_list  ->  statements_list . statement   (rule 4)
    statement  ->  LEFT_BRACE statements_list . RIGHT_BRACE   (rule 12)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    RIGHT_BRACE	shift, and go to state 46
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 47
    expression	go to state 16



state 26

    statements_list  ->  statement .   (rule 3)

    $default	reduce using rule 3 (statements_list)



state 27

    expression  ->  LEFT_PAREN expression . RIGHT_PAREN   (rule 28)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    RIGHT_PAREN	shift, and go to state 48
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 28

    final  ->  final statement .   (rule 2)

    $default	reduce using rule 2 (final)



state 29

    statement  ->  expression SEMICOLON .   (rule 11)

    $default	reduce using rule 11 (statement)



state 30

    expression  ->  expression ASSIGN . expression   (rule 35)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 49



state 31

    expression  ->  expression ADD . expression   (rule 31)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 50



state 32

    expression  ->  expression SUB . expression   (rule 32)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 51



state 33

    expression  ->  expression MUL . expression   (rule 33)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 52



state 34

    expression  ->  expression DIV . expression   (rule 34)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 53



state 35

    expression  ->  expression LEFT_PAREN . RIGHT_PAREN   (rule 29)
    expression  ->  expression LEFT_PAREN . arguments RIGHT_PAREN   (rule 30)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    RIGHT_PAREN	shift, and go to state 54
    LEFT_PAREN	shift, and go to state 13

    arguments	go to state 55
    expression	go to state 56



state 36

    statement  ->  IF LEFT_PAREN expression . RIGHT_PAREN statement   (rule 15)
    statement  ->  IF LEFT_PAREN expression . RIGHT_PAREN statement ELSE statement   (rule 16)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    RIGHT_PAREN	shift, and go to state 57
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 37

    statement  ->  FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON expression RIGHT_PAREN statement   (rule 17)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    SEMICOLON	shift, and go to state 58
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 38

    statement  ->  WHILE LEFT_PAREN expression . RIGHT_PAREN statement   (rule 18)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    RIGHT_PAREN	shift, and go to state 59
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 39

    statement  ->  DO statement WHILE . LEFT_PAREN expression RIGHT_PAREN SEMICOLON   (rule 19)

    LEFT_PAREN	shift, and go to state 60



state 40

    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN . parameters RIGHT_PAREN statement   (rule 24)
    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN statement   (rule 25)

    IDENTIFIER	shift, and go to state 41
    RIGHT_PAREN	shift, and go to state 61

    parameters	go to state 62



state 41

    parameters  ->  IDENTIFIER .   (rule 5)

    $default	reduce using rule 5 (parameters)



state 42

    expression  ->  FUNCTION LEFT_PAREN RIGHT_PAREN . statement   (rule 27)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 63
    expression	go to state 16



state 43

    parameters  ->  parameters . COMMA IDENTIFIER   (rule 6)
    expression  ->  FUNCTION LEFT_PAREN parameters . RIGHT_PAREN statement   (rule 26)

    RIGHT_PAREN	shift, and go to state 64
    COMMA	shift, and go to state 65



state 44

    statement  ->  VAR IDENTIFIER SEMICOLON .   (rule 13)

    $default	reduce using rule 13 (statement)



state 45

    statement  ->  VAR IDENTIFIER ASSIGN . expression SEMICOLON   (rule 14)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 66



state 46

    statement  ->  LEFT_BRACE statements_list RIGHT_BRACE .   (rule 12)

    $default	reduce using rule 12 (statement)



state 47

    statements_list  ->  statements_list statement .   (rule 4)

    $default	reduce using rule 4 (statements_list)



state 48

    expression  ->  LEFT_PAREN expression RIGHT_PAREN .   (rule 28)

    $default	reduce using rule 28 (expression)



state 49

    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)
    expression  ->  expression ASSIGN expression .   (rule 35)

    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 35 (expression)



state 50

    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression ADD expression .   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 31 (expression)



state 51

    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression SUB expression .   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 32 (expression)



state 52

    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression MUL expression .   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 33 (expression)



state 53

    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression DIV expression .   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 34 (expression)



state 54

    expression  ->  expression LEFT_PAREN RIGHT_PAREN .   (rule 29)

    $default	reduce using rule 29 (expression)



state 55

    arguments  ->  arguments . COMMA expression   (rule 8)
    expression  ->  expression LEFT_PAREN arguments . RIGHT_PAREN   (rule 30)

    RIGHT_PAREN	shift, and go to state 67
    COMMA	shift, and go to state 68



state 56

    arguments  ->  expression .   (rule 7)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 7 (arguments)



state 57

    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN . statement   (rule 15)
    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN . statement ELSE statement   (rule 16)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 69
    expression	go to state 16



state 58

    statement  ->  FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON expression RIGHT_PAREN statement   (rule 17)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 70



state 59

    statement  ->  WHILE LEFT_PAREN expression RIGHT_PAREN . statement   (rule 18)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 71
    expression	go to state 16



state 60

    statement  ->  DO statement WHILE LEFT_PAREN . expression RIGHT_PAREN SEMICOLON   (rule 19)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 72



state 61

    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . statement   (rule 25)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 73
    expression	go to state 16



state 62

    parameters  ->  parameters . COMMA IDENTIFIER   (rule 6)
    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN parameters . RIGHT_PAREN statement   (rule 24)

    RIGHT_PAREN	shift, and go to state 74
    COMMA	shift, and go to state 65



state 63

    expression  ->  FUNCTION LEFT_PAREN RIGHT_PAREN statement .   (rule 27)

    $default	reduce using rule 27 (expression)



state 64

    expression  ->  FUNCTION LEFT_PAREN parameters RIGHT_PAREN . statement   (rule 26)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 75
    expression	go to state 16



state 65

    parameters  ->  parameters COMMA . IDENTIFIER   (rule 6)

    IDENTIFIER	shift, and go to state 76



state 66

    statement  ->  VAR IDENTIFIER ASSIGN expression . SEMICOLON   (rule 14)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    SEMICOLON	shift, and go to state 77
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 67

    expression  ->  expression LEFT_PAREN arguments RIGHT_PAREN .   (rule 30)

    $default	reduce using rule 30 (expression)



state 68

    arguments  ->  arguments COMMA . expression   (rule 8)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 78



state 69

    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN statement .   (rule 15)
    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN statement . ELSE statement   (rule 16)

    ELSE	shift, and go to state 79

    $default	reduce using rule 15 (statement)



state 70

    statement  ->  FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON expression RIGHT_PAREN statement   (rule 17)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    SEMICOLON	shift, and go to state 80
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 71

    statement  ->  WHILE LEFT_PAREN expression RIGHT_PAREN statement .   (rule 18)

    $default	reduce using rule 18 (statement)



state 72

    statement  ->  DO statement WHILE LEFT_PAREN expression . RIGHT_PAREN SEMICOLON   (rule 19)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    RIGHT_PAREN	shift, and go to state 81
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 73

    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN statement .   (rule 25)

    $default	reduce using rule 25 (expression)



state 74

    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN parameters RIGHT_PAREN . statement   (rule 24)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 82
    expression	go to state 16



state 75

    expression  ->  FUNCTION LEFT_PAREN parameters RIGHT_PAREN statement .   (rule 26)

    $default	reduce using rule 26 (expression)



state 76

    parameters  ->  parameters COMMA IDENTIFIER .   (rule 6)

    $default	reduce using rule 6 (parameters)



state 77

    statement  ->  VAR IDENTIFIER ASSIGN expression SEMICOLON .   (rule 14)

    $default	reduce using rule 14 (statement)



state 78

    arguments  ->  arguments COMMA expression .   (rule 8)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35

    $default	reduce using rule 8 (arguments)



state 79

    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN statement ELSE . statement   (rule 16)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 83
    expression	go to state 16



state 80

    statement  ->  FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . expression RIGHT_PAREN statement   (rule 17)

    FUNCTION	shift, and go to state 5
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_PAREN	shift, and go to state 13

    expression	go to state 84



state 81

    statement  ->  DO statement WHILE LEFT_PAREN expression RIGHT_PAREN . SEMICOLON   (rule 19)

    SEMICOLON	shift, and go to state 85



state 82

    expression  ->  FUNCTION IDENTIFIER LEFT_PAREN parameters RIGHT_PAREN statement .   (rule 24)

    $default	reduce using rule 24 (expression)



state 83

    statement  ->  IF LEFT_PAREN expression RIGHT_PAREN statement ELSE statement .   (rule 16)

    $default	reduce using rule 16 (statement)



state 84

    statement  ->  FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression . RIGHT_PAREN statement   (rule 17)
    expression  ->  expression . LEFT_PAREN RIGHT_PAREN   (rule 29)
    expression  ->  expression . LEFT_PAREN arguments RIGHT_PAREN   (rule 30)
    expression  ->  expression . ADD expression   (rule 31)
    expression  ->  expression . SUB expression   (rule 32)
    expression  ->  expression . MUL expression   (rule 33)
    expression  ->  expression . DIV expression   (rule 34)
    expression  ->  expression . ASSIGN expression   (rule 35)

    RIGHT_PAREN	shift, and go to state 86
    ASSIGN	shift, and go to state 30
    ADD 	shift, and go to state 31
    SUB 	shift, and go to state 32
    MUL 	shift, and go to state 33
    DIV 	shift, and go to state 34
    LEFT_PAREN	shift, and go to state 35



state 85

    statement  ->  DO statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .   (rule 19)

    $default	reduce using rule 19 (statement)



state 86

    statement  ->  FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN . statement   (rule 17)

    IF  	shift, and go to state 1
    FOR 	shift, and go to state 2
    WHILE	shift, and go to state 3
    DO  	shift, and go to state 4
    FUNCTION	shift, and go to state 5
    VAR 	shift, and go to state 6
    DOUBLE_LITERAL	shift, and go to state 7
    INTEGER_LITERAL	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    IDENTIFIER	shift, and go to state 10
    LEFT_BRACE	shift, and go to state 11
    SEMICOLON	shift, and go to state 12
    LEFT_PAREN	shift, and go to state 13

    statement	go to state 87
    expression	go to state 16



state 87

    statement  ->  FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN statement .   (rule 17)

    $default	reduce using rule 17 (statement)



state 88

    $   	go to state 89



state 89

    $default	accept
